\section{
ماژول
\lr{QuGAN}
}
ماژول
\lr{QuGAN}
بر اساس شبکه‌های زایای دشمن‌گونه‌ی کوانتومی که در بخش
\ref{sec:qugan}
معرفی شد طراحی شده است.
این ماژول نیز همانند ماژول
\lr{QLSTM}
از ماژول
\lr{Midi}
برای پیش‌پردازش داده‌ها استفاده می‌کند.

این ماژول به طور کلی شامل سه زیرمدار کوانتومی است. از ترکیب‌های مختلف این سه زیرمدار، سه مدار کوانتومی تشکیل می‌شود که توضیح کارکرد آن‌ها در زیر آمده است:

\begin{itemize}
    \item زیرمدار اول که در کد پروژه توسط تابع
    \lr{encode\_music}
    ساخته می‌شود، با دریافت نت‌هایی به عنوان ورودی، آن‌ها را با استفاده از تابع
    \lr{AmplitudeEmbedding}
    در کیوبیت‌های سیستم کدگذاری می‌کند.
    
    \item زیرمدار دوم که زیرمداری پارامتریک است و در کد پروژه توسط تابع
    \lr{discriminator}
    ساخته می‌شود، با استفاده از تابع
    \lr{RandomLayers}
    لایه‌هایی پارامتریک تولید می‌کند. این لایه‌ها سعی در تشخیص واقعی یا ساختگی بودن داده‌های موجود در کیوبیت‌ها دارند و عمل‌کرد متمایزکنندگی شبکه را پیاده‌سازی می‌کنند.
    خروجی این زیرمدار، آرایه‌ای متشکل از امیدریاضی اندازه‌گیری تک‌تک کیوبیت‌های سیستم به صورت مجزا است.
    
    \item زیرمدار سوم، همانند زیر مدار دوم مداری پارامتریک است، اما سعی در تولید داده‌هایی ساختگی از روی کیوبیت‌هایی که مقداری نویز به عنوان داده‌ی اولیه بر روی آن‌ها کدگذاری شده‌اند دارد. این زیرمدار در کد پروژه توسط تابع
    \lr{music\_generator}
    ساخته می‌شود و عملکرد زایایی شبکه را پیاده‌سازی می‌کند.
\end{itemize}

و مدارهای کوانتومی این ماژول، به این شکل ساخته شده‌اند:
\begin{itemize}
    \item
    مدار اول که
    \lr{real\_music\_discriminator}
    نام دارد،
    ابتدا به کمک تابع
    \lr{encode\_music}
    تعدادی نت از مجموعه داده گرفته و آن‌ها را در کیوبیت‌های سیستم کدگذاری می‌کند، سپس زیرمدار
    \lr{discriminator}
    سعی می‌کند با بهینه‌سازی پارامترهای خود تشخیص دهد آیا داده‌ها واقعی هستند یا خیر.
    
    \item
    مدار دوم که
    \lr{generated\_music\_discriminator}،
    نام دارد، ابتدا با گرفتن مقداری نویز به عنوان ورودی، آن نویزها را توسط
    \lr{encode\_music}
    در سیستم کدگذاری می‌کند، سپس زیرمدار \\
    \lr{music\_generator}
    با بهینه‌سازی پارامترهای خود، اقدام به ساخت داده‌ی جدیدی از روی نویز کدگذاری شده می‌کند و در نهایت، زیرمدار
    \lr{discriminator}
    سعی می‌کند با بهینه‌سازی پارامترهای خود، تشخیص دهد آیا داده یکی از داده‌های واقعی است یا خیر.
    
    \item
    مدار سوم که
    \lr{final\_music\_generator}
    نام دارد، با ترکیب زیرمدار‌های
    \lr{encode\_music}
    و \\
    \lr{music\_generator}
    ابتدا مقداری نویز را در سیستم کدگذاری کرده و سپس آرایه‌ای متشکل از امیدریاضی اندازه‌گیری تک‌تک کیوبیت‌های سیستم را به عنوان خروجی تولید می‌کند که نتیجه‌ی نهایی الگوریتم، از این خروجی ساخته می‌شود.
    
\end{itemize}
نکته‌ی اصلی این است که بعد از هربار اجرای مدارهای اول و دوم، وزن‌های زیرمدار
\lr{discriminator}
آن‌ها با هم همگام می‌شوند، چراکه در کل برنامه باید تنها یک
\lr{discriminator}
وجود داشته‌باشد.

بعد از ساخته‌شدن این مدارها، با استفاده از توابع هزینه‌ی معرفی شده در معادله‌ی
\ref{eqn:qugan_cost}
پارامترهای زیرمدارهای 
\lr{discriminator}
و
\lr{music\_generator}
بهینه‌سازی می‌شوند؛ سپس پارامترهای زیرمدار
\lr{music\_generator} 
موجود در مدار دوم با پارامترهای مدار سوم همگام‌سازی شده و پس از پس‌پردازش خروجی‌های مدار سوم، موسیقی تولید می‌شود.

\subsection{پس‌پردازش}

\begin{algorithm}[t]
\caption{پس‌پردازش ماژول \lr{QuGAN}} \label{alg:quganpost}
\lr{
    \begin{algorithmic}
        \STATE $model\_output_i = model(input_i)$
        \STATE $model\_output_i = (model\_output_i + 1) * norm_i$
        \STATE $counter = 1$
        \WHILE {$model\_output_i \not\in mapping.keys()$}
        \STATE $model\_output_i = model\_output_i * counter / (counter+1)$
        \STATE $model\_output_i = model\_output_i.to\_int()$
        \STATE $counter = counter + 1$
        \ENDWHILE
    \end{algorithmic} 
}
\end{algorithm}
\myalgorithms{
    الگوریتم پس‌پردازش ماژول
    \lr{QuGAN}
}

به همان دلیل ارائه شده در بخش
\ref{sec:qlstm_post}،
داده‌های این ماژول نیز نیاز به پس‌پردازش دارد، اما این ماژول برای تولید قطعات موسیقی آهنگین‌تر، نیاز به پس‌پردازش متفاوتی دارد.
پس‌پردازش استفاده شده در این ماژول طبق الگوریتم
\ref{alg:quganpost}
عمل می‌کند.
در این الگوریتم، همانند پس‌پردازش ماژول
\lr{QLSTM}،
متغیرهای
$input_i$
و
$norm_i$
طبق معادله‌ی
\ref{eqn:midi_data}
تعریف شده‌اند. 
منظور از 
\lr{mapping}
همان نگاشت یک به یک از نت‌ها به اعداد طبیعی است و
$model\_output_i$
خروجی نهایی بعد از پس‌پردازش،
است.
در نهایت، تابع
\lr{generate\_notes}
با گرفتن پارامتر
\lr{n\_notes}
با چندین‌بار اجرای الگوریتم، به تعداد
\lr{n\_notes}
نت موسیقی جدید تولید کرده و آن‌ها را در یک فایل با پسوند
\lr{midi}
ذخیره می‌کند.
