
\section{ماژول
\lr{QLSTM}
} \label{sec:qlstm_module}
ماژول
\lr{QLSTM}
بر اساس حافظه‌های طولانی کوتاه-مدت کوانتومی که در بخش
\ref{sec:qlstm}
معرفی شدند طراحی شده است.
در کتاب‌خانه‌ی 
\lr{PyTorch}،
هر مدل تمرین‌پذیر یادگیری ماشین، زیرکلاسی از کلاس \\
\lr{torch.nn.Module}
است. به همین دلیل، کلاس‌های این ماژول، همگی زیرکلاسی از
\lr{torch.nn.Module}
هستند. این کلاس‌ها در زیر شرح داده می‌شوند.

\subsection{
کلاس
\lr{QLSTMCell}
}
هر واحد بازگشتی کوانتومی این الگوریتم در کلاس
\lr{QLSTMCell}
تعریف شده.
ورودی‌های مهمی که برای ساختن نمونه‌ای از این کلاس لازم است به شرح زیر هستند:
\begin{itemize}
    \item 
    \lr{n\_qubits}
    تعداد کیوبیت‌های استفاده شده در مدارهای کوانتومی این واحد بازگشتی است.
    \item
    \lr{n\_qlayers}
    تعداد لایه‌های موجود در قسمت پارامتردار مدارهای کوانتومی را تعیین می‌کند.
    \item
    \lr{input\_size}
    ابعاد داده‌های ورودی به واحد بازگشتی را تعیین می‌کند.
    \item
    \lr{hidden\_size}
    ابعاد داده‌ی خروجی واحد بازگشتی را تعیین می‌کند.
\end{itemize}

این کلاس سپس با استفاده از پارامترهای دریافت شده، چهار مدار کوانتومی برای گیت‌های بازگشتی می‌سازد.
هر کدام از این مدارهای کوانتومی، از ترکیب تابع کدگذاری
\lr{AmplitudeEmbedding}
و تابع پارامتریک
\lr{RandomLayers}
کتاب‌خانه‌ی
\lr{PennyLane}
ساخته شده است.

هر تابع
\lr{AmplitudeEmbedding}
با دریافت ورودی‌ای با ابعاد
$2^n$،
آن را در 
$n$
کیوبیت هدف به صورت زیر کدگذاری می‌کند:
\begin{equation} \label{eqn:midi_data}
    \begin{gathered}
       input = [a_0, a_1, a_{2^n-1}] \hst ; \hst a_i \in \mathbb{R} \\[3pt]
       norm = \sqrt{\sum^{2^n}_{i=0} a_i^2 } \\[3pt]
       output = \frac{a_0}{norm} |00...0\rangle + \frac{a_1}{norm} |00...1\rangle + ... + \frac{a_{2^n-1}}{norm} |11...1\rangle
    \end{gathered}
\end{equation}
\myequations{
نحوه‌ی کارکرد تابع
\lr{AmplitudeEmbedding}
}

و هر تابع 
\lr{RandomLayers}
با دریافت یک ورودی با ابعاد
$(L, k)$
و یک عدد طبیعی
\lr{seed}
،تعداد
$L$
لایه‌ی پارامتریک را با استفاده از
\lr{seed}
به صورت تصادفی تولید می‌کند.
هر لایه‌ی تولید شده توسط
\lr{RandomLayers}
شامل ترکیبی از 
$k$
گیت کوانتومی پارامتریک و تعدادی گیت 
$CNOT$
است.

پس هر واحد بازگشتی در پیاده‌سازی فعلی، یک
\lr{QLSTMCell}
است که مدارهای کوانتومی آن، از پشت سرهم قرار گرفتن زیرمدارهای تولید شده توسط
\lr{AmplitudeEmbedding}
و
\lr{RandomLayers}
ساخته شده‌اند و در نهایت، آرایه‌ای متشکل از امیدریاضی اندازه‌گیری جداگانه‌ی تک‌تک کیوبیت‌های هر مدار، به عنوان خروجی آن مدار در نظر گرفته می‌شود.

\subsection{
کلاس
\lr{QLSTM}
}
این کلاس با دریافت ورودی‌ای با نام
\lr{n\_layers}،
تعداد
\lr{n\_layers}
لایه از 
\lr{QLSTMCell}
ها را در کنار هم قرار می‌دهد و تغییرات لازم برای رد کردن خروجی‌های هرکدام از این لایه‌ها به عنوان ورودی لایه‌ی بعدی را انجام می‌دهد.

\subsection{
کلاس
\lr{QLSTMusic}
}
با گرفتن ورودی و خروجی‌های تولید شده از ماژول
\lr{Midi}،
و یک عدد طبیعی
\lr{n\_epochs}،
به تعداد
\lr{n\_epochs}
بار
ورودی و خروجی‌ها را به یک 
\lr{QLSTM}
رد می‌کند و پارامترهای آن را برای کمینه‌کردن یک تابع هزینه، بهینه‌سازی می‌کند.

\subsection{پس‌پردازش} \label{sec:qlstm_post}
\begin{algorithm}[t]
\caption{پس‌پردازش ماژول \lr{QLSTM}}  \label{alg:qlstmpost}
\lr{
    \begin{algorithmic}
        \STATE $raw\_model\_output_i = QLSTMCell(input_i)$
        \STATE $model\_output_i = mean(raw\_model\_output_i)$
        \STATE $model\_output_i = model\_output_i * norm_i$
    \end{algorithmic}
}
\end{algorithm}
\myalgorithms{
    الگوریتم پس‌پردازش ماژول
    \lr{QLSTM}
}
هر لایه از
\lr{QLSTM}
که شامل
$n$
کیوبیت باشد، 
$n$
خروجی که هر کدام از آن‌ها عددی در بازه‌ی
$[-1, 1]$
است تولید می‌کند. به همین دلیل، برای تبدیل کردن این اعداد به اعداد طبیعی‌ای که معادل نت‌های مجموعه داده باشند، باید روی خروجی‌ها پس‌پردازش انجام داد.
پس‌پردازش پیشنهادی در این مرحله، در الگوریتم
\ref{alg:qlstmpost}
آمده است. در این الگوریتم، متغیرهای
$input_i$
و
$norm_i$
طبق معادله‌ی
\ref{eqn:midi_data}
تعریف شده‌اند،
$raw\_model\_output_i$
خروجی اولیه‌ای است که از مدار کوانتومی گرفته می‌شود و
$model\_output_i$
خروجی نهایی بعد از پس‌پردازش است.



% برای هر
% \lr{QLSTMCell}،
% پس از پاس‌داده‌شدن
% $input_i$
% به شکلی که در معادله‌ی
% \ref{eqn:midi_data}
% تعریف شده، 
% یک
% $modelOutput_i$
% تولید می‌شود که شامل
% $n$
% عدد است.
% ابتدا از خروجی‌های داده‌شده توسط هر کدام از واحدهای بازگشتی میانگین گرفته می‌شود و سپس با ضرب این میانگین
% در
% $norm_i$،
% عدد طبیعی معادل نت پیشنهادی هر
% \lr{QLSTMCell}
% تولید می‌شود.

\subsection{تابع هزینه}
به علت این‌که ممکن است عدد طبیعی معادل نت پیشنهادی، بزرگ‌تر یا کوچک‌تر از عدد طبیعی معادل نت خروجی مجموعه داده باشد، از تابع خطای میانگین مربعات که در معادله‌ی
\ref{eqn:mse}
معرفی شد، به عنوان تابع هزینه استفاده می‌شود.

در نهایت، تابع
\lr{generate\_notes}
با گرفتن پارامتر
\lr{n\_notes}
با چندین‌بار اجرای الگوریتم، به تعداد
\lr{n\_notes}
نت موسیقی جدید تولید کرده و آن‌ها را در یک فایل با پسوند
\lr{midi}
ذخیره می‌کند.

